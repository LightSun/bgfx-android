


diag

建立对角矩阵或获取对角向量

rot90

将矩阵旋转90度

fliplr

按左右方向翻转矩阵元素

tril

取矩阵的下三角部分

flipud

按上下方向翻转矩阵元素

triu

取矩阵的上三角部分

repmat

复制并排列矩阵函数

================= nanovg =======
中文文本的渲染
========= nanvans ==========
from: https://github.com/Geequlim/NanoCanvas

================ draw to framebuffer ======
// Helper functions to create bgfx framebuffer to render to.
// Example:
//		float scale = 2;
//		NVGLUframebuffer* fb = nvgluCreateFramebuffer(ctx, 100 * scale, 100 * scale, 0);
//		nvgluSetViewFramebuffer(VIEW_ID, fb);
//		nvgluBindFramebuffer(fb);
//		nvgBeginFrame(ctx, 100, 100, scale);
//		// renders anything offscreen
//		nvgEndFrame(ctx);
//		nvgluBindFramebuffer(NULL);
//
//		// Pastes the framebuffer rendering.
//		nvgBeginFrame(ctx, 1024, 768, scale);
//		NVGpaint paint = nvgImagePattern(ctx, 0, 0, 100, 100, 0, fb->image, 1);
//		nvgBeginPath(ctx);
//		nvgRect(ctx, 0, 0, 100, 100);
//		nvgFillPaint(ctx, paint);
//		nvgFill(ctx);
//		nvgEndFrame(ctx);

void requestScreenShot(
		  FrameBufferHandle _handle
		, const char* _filePath
		);

======================== LineCap/LineJoin =======
like javafx.scene.shape.StrokeLineCap and StrokeLineJoin

=============
NVGcontext: add ref count.


============ pitch =================
总结：width就是图像实际显示的宽度。而pitch是存储的一行图像所占的字节(相邻两行起点指针的差值)
   width和pitch的单位不同：width是像素，pitch是字节byte.因此一个640*480*8的位图和640*480*24的位图的width相同但pitch不同。
   pitch可能大于width个像素所占字节。有时为了高效处理，会将每个图形都对齐存储bgfx_calc_texture_size，这样pitch就包括了对齐使用的填充字节。

=============== todo =====================
-- do on config change, like surface-changed, redraw
-- Test SortedList
-- layout(like RecyclerView, ScrollView)
-- full image transform
-- draw chinese
-- tint

